# 코드 리뷰 강화 제안

> "무엇을 바꾸느냐보다 왜 그렇게 판단했는가"를 기준으로 한 추가 관점 제안

## 📌 현재 리뷰의 강점과 한계

### ✅ 잘 된 부분
- 55개의 체계적인 리뷰 포인트
- 일관된 형식 (문제-원인-개선안-전후비교-측정치-참고링크)
- 기술적 정확성과 세부사항

### ⚠️ 보완이 필요한 "왜"의 측면

1. **비즈니스 영향도가 추상적임**
2. **실제 장애 시나리오 부족**
3. **트레이드오프 분석의 깊이 부족**
4. **의사결정 우선순위 판단 근거 미흡**
5. **장기적 유지보수 관점 부족**

---

## 🎯 추가하면 좋을 "왜" 관점들

### 1. 비즈니스 영향도 강화

**현재 방식:**
```
문제: Product 엔티티를 직접 반환하여 도메인 모델이 API에 노출됨
원인: DTO 변환 레이어 누락
```

**개선된 방식:**
```
문제: Product 엔티티를 직접 반환하여 도메인 모델이 API에 노출됨
원인: DTO 변환 레이어 누락

왜 이것이 비즈니스에 중요한가?
- 시나리오: 3개월 후 Product에 supplierPrice(공급가) 필드 추가 시 자동으로
  외부 API에 노출 → 파트너사가 우리의 마진율을 알게 됨
- 실제 영향: API 버전 관리 없이는 긴급 롤백 필요 → 서비스 중단
- 비용: API 계약 위반으로 파트너사 재협상 필요 → 비즈니스 손실

트레이드오프 분석:
1. DTO 도입 비용: 개발 2시간, 코드 증가 20%
2. 미도입 리스크: 향후 API 변경마다 하위 호환성 이슈 발생 가능성 80%
3. 결론: 초기 비용보다 장기적 리스크가 훨씬 큼
```

### 2. 실제 운영 시나리오 추가

**예시: 리뷰 #13 (트랜잭션 관리)**

**현재 방식:**
```
문제: @Transactional 어노테이션이 없어 트랜잭션 경계가 불명확함
개선안: @Transactional 추가
```

**개선된 방식:**
```
문제: @Transactional 어노테이션이 없어 트랜잭션 경계가 불명확함

실제 장애 시나리오:
1. 상황: 하루 10만 건의 상품 업데이트 요청 처리 중
2. 발생 가능한 문제:
   - update() 메서드 실행 중 서버 장애 발생
   - product.setCategory()는 실행됐지만 product.setName()은 실행 안 됨
   - DB에는 category만 변경된 불완전한 데이터 저장
3. 영향:
   - 고객에게 잘못된 상품 정보 노출
   - 데이터 정합성 깨짐
   - 원인 추적 어려움 (로그에 일부만 성공한 기록 없음)

동시성 이슈 시나리오:
- 사용자 A: 상품 이름을 "노트북" → "게이밍 노트북" 수정
- 사용자 B: 동시에 같은 상품 카테고리를 "전자제품" → "컴퓨터" 수정
- 트랜잭션 격리 수준 없이 실행 시 Lost Update 발생 가능
- 결과: 둘 중 하나의 변경사항이 유실됨

왜 이제 고쳐야 하는가?
- 현재 H2 in-memory, 단일 인스턴스라서 문제가 안 보임
- 운영 배포 시 다중 인스턴스 + PostgreSQL 환경에서는 즉시 문제 발생
- 문제가 발견된 후 수정하면 롤백 비용이 10배 증가
```

### 3. 의사결정 우선순위 판단 근거

**예시: 왜 이것이 Critical이고 저것은 Medium인가?**

**리뷰 #6 (HTTP 메서드 오용) - Critical 판단 근거:**
```
왜 Critical로 분류했는가?

1. 표준 위반의 파급력:
   - HTTP 프록시/캐시 서버가 POST는 캐싱 안 함
   - DELETE는 멱등성 보장으로 CDN/캐시 활용 가능
   - 트래픽 10% 증가 시 캐싱 없으면 서버 비용 2배 증가

2. 보안 취약점:
   - POST /delete/product/1을 GET처럼 사용하면 CSRF 취약점
   - 웹 크롤러가 링크 따라가다가 데이터 삭제할 수 있음
   - 실제 사례: GitHub의 DELETE가 GET으로 구현되어 크롤러가 레포 삭제한 사건

3. 수정 비용 vs 타이밍:
   - 지금 수정: 30분, 영향 범위 0 (아직 배포 전)
   - 운영 후 수정: API 버전 관리 필요, 클라이언트 마이그레이션 필요 → 2주 소요
   - 결론: 지금이 40배 저렴함

우선순위 판단 기준:
Critical = (영향도: 높음) × (수정비용: 낮음) × (표준위반: 심각)
```

**리뷰 #28 (중복 getter) - Medium 판단 근거:**
```
왜 Medium으로 분류했는가?

1. 영향도 분석:
   - 기능적 문제 없음 (Lombok이 덮어씀)
   - 성능 영향 없음 (컴파일 타임 처리)
   - 보안 이슈 없음

2. 문제의 본질:
   - 코드 가독성 저하 (중복 코드 약 10줄)
   - 유지보수 시 혼란 ("어느 getter가 사용되지?")
   - 팀 컨벤션 위반 (Lombok 사용 목적에 반함)

3. 수정 효과:
   - 수정 시간: 1분
   - 얻는 이익: 가독성 향상, 일관성 확보
   - 리스크: 거의 없음

4. 왜 Critical이 아닌가?
   - 즉시 서비스에 영향 없음
   - 코드 품질 개선이지 버그 수정은 아님
   - 다른 Critical 이슈 수정 후 처리해도 무방

우선순위 판단 기준:
Medium = (영향도: 낮음) × (수정비용: 낮음) × (코드품질: 중요)
```

### 4. 트레이드오프 심층 분석

**예시: 리뷰 #17 (JPA Dirty Checking)**

**현재 방식:**
```
개선안: @Transactional 추가 후 save() 호출 제거
```

**개선된 방식:**
```
개선안 비교 분석:

┌─────────────────────────────────────────────────────────┐
│ 옵션 A: 명시적 save() 유지 (현재 방식)                  │
├─────────────────────────────────────────────────────────┤
│ 장점:                                                    │
│ - 명시적이라 초보자가 이해하기 쉬움                     │
│ - "저장한다"는 의도가 코드에 드러남                     │
│                                                          │
│ 단점:                                                    │
│ - 불필요한 SELECT 쿼리 1회 추가 (save는 merge 수행)    │
│ - 100 TPS 기준 하루 86,400번의 불필요한 쿼리           │
│ - DB 커넥션 점유 시간 증가 → 커넥션 풀 고갈 위험       │
│                                                          │
│ 언제 사용하는가?                                        │
│ - detached 엔티티를 다시 영속화할 때                   │
│ - 명시적 저장 시점 제어가 필요할 때                     │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ 옵션 B: Dirty Checking 활용 (권장)                      │
├─────────────────────────────────────────────────────────┤
│ 장점:                                                    │
│ - 쿼리 1회 감소 (SELECT 제거)                           │
│ - JPA 의도대로 사용 (Spring Data JPA best practice)    │
│ - 성능: 동일 작업 30-50% 빠름                           │
│                                                          │
│ 단점:                                                    │
│ - @Transactional 누락 시 동작 안 함 (런타임 버그)      │
│ - 변경 감지 시점이 불명확 (트랜잭션 커밋 시)            │
│ - 초보자가 "왜 save() 안 해도 되지?" 혼란               │
│                                                          │
│ 언제 사용하는가?                                        │
│ - 트랜잭션 내에서 엔티티 수정하는 대부분의 경우        │
│ - Spring Data JPA 표준 패턴                             │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ 옵션 C: 도메인 메서드로 캡슐화 (고급)                   │
├─────────────────────────────────────────────────────────┤
│ 코드:                                                    │
│   public class Product {                                │
│     public void updateInfo(String category, String name) {│
│       validateCategory(category);                       │
│       validateName(name);                               │
│       this.category = category;                         │
│       this.name = name;                                 │
│     }                                                    │
│   }                                                      │
│                                                          │
│ 장점:                                                    │
│ - 비즈니스 규칙을 엔티티에 캡슐화                       │
│ - setter 제거로 불변성 향상                             │
│ - 도메인 주도 설계(DDD) 원칙 준수                       │
│ - 변경 이력 추적 용이 (updateInfo 호출만 추적)         │
│                                                          │
│ 단점:                                                    │
│ - 초기 설계 비용 증가                                   │
│ - 모든 변경 시나리오마다 메서드 필요                    │
│                                                          │
│ 언제 사용하는가?                                        │
│ - 복잡한 비즈니스 규칙이 있을 때                        │
│ - 도메인 로직이 중요한 서비스일 때                      │
└─────────────────────────────────────────────────────────┘

의사결정 기준:
┌──────────────┬─────────┬──────────┬────────────┐
│              │ 옵션 A  │  옵션 B  │   옵션 C   │
├──────────────┼─────────┼──────────┼────────────┤
│ 구현 난이도  │  쉬움   │   보통   │   어려움   │
│ 성능         │  낮음   │   높음   │   높음     │
│ 유지보수성   │  보통   │   보통   │   우수     │
│ 러닝 커브    │  낮음   │   보통   │   높음     │
└──────────────┴─────────┴──────────┴────────────┘

권장 선택:
- 레거시 개선: 옵션 B (가장 빠른 개선 효과)
- 신규 프로젝트: 옵션 C (장기적 품질)
- 프로토타입: 옵션 A (빠른 개발)
```

### 5. 아키텍처 레벨의 "왜"

**현재 누락된 전체적 관점:**

```
[아키텍처 리뷰 A - 계층 간 책임 분리 부재]

문제: Controller, Service, Repository의 책임이 명확히 분리되지 않음

구체적 증거:
1. Controller가 비즈니스 결정을 함
   - ProductController에서 Page → ProductListResponse 변환
   - 이것은 Service의 책임

2. Service가 데이터 변환을 함
   - ProductService가 도메인 로직 없이 CRUD만 수행
   - Repository 호출을 감싸기만 하는 얇은 레이어

3. Repository에 비즈니스 로직이 들어갈 여지
   - findAllByCategory가 정렬 기준을 Repository가 결정할 수 있음

왜 이것이 문제인가?

1. 유지보수성:
   - 6개월 후 "상품 수정 시 이력을 남겨야 함" 요구사항 추가
   - 현재 구조: Controller? Service? 어디에 넣어야 할지 불명확
   - 올바른 구조: Service에 명확히 위치

2. 테스트 가능성:
   - Controller 테스트 시 Service와 분리 어려움
   - Mock 경계가 불명확

3. 팀 협업:
   - 신입 개발자가 "어느 레이어에 코드를 추가해야 하나?" 혼란
   - 코드 리뷰 시 "이건 여기 있으면 안 되는데" 논쟁 발생

올바른 책임 분배:

Controller 책임:
✅ HTTP 요청/응답 처리
✅ DTO ↔ Domain 변환
✅ 입력 검증 (@Valid)
❌ 비즈니스 로직
❌ 데이터 접근

Service 책임:
✅ 비즈니스 로직 수행
✅ 트랜잭션 관리
✅ 여러 Repository 조율
❌ HTTP 관심사
❌ SQL 쿼리 작성

Repository 책임:
✅ 데이터 접근
✅ 쿼리 최적화
❌ 비즈니스 규칙
❌ 데이터 변환

개선 방향:
1. Service에 실제 비즈니스 로직 추가
   - updateProduct()에서 카테고리 변경 시 재고 확인 로직
   - deleteProduct()에서 주문 존재 여부 확인

2. Controller는 얇게 유지
   - HTTP → Service 호출 → DTO 변환만

3. 각 레이어에 명확한 책임 문서화
```

### 6. 유지보수성 관점의 "왜"

**예시: 리뷰 #12 (메서드명 중복)**

```
문제: getProductListByCategory() 메서드명이 중복

왜 이것이 장기적으로 문제인가?

6개월 후 시나리오:
1. 주니어 개발자 입사
2. "카테고리별 상품 목록 API에 정렬 기능 추가" 업무 할당
3. IntelliJ에서 "getProductListByCategory" 검색
4. 2개 발견:
   - 하나는 상품 목록 반환 (Line 254)
   - 하나는 카테고리 목록 반환 (Line 278)
5. 혼란: "어느 게 맞는 거지?"
6. 잘못된 메서드 수정 → 버그 발생

실제 비용:
- 코드 이해 시간: 5분 → 20분 (4배 증가)
- 잘못된 메서드 수정 확률: 50%
- 버그 수정 비용: 개발 2시간 + QA 1시간 + 배포 30분

누적 효과:
- 팀원 10명 × 월 1회 혼란 = 연간 120회
- 연간 손실 시간: 30시간
- 비용: 주니어 개발자 시급 기준 150만원

반면 지금 수정 비용:
- 메서드명 변경: 1분
- 테스트: 2분
- 총 비용: 3분

ROI: (150만원 절감) / (3분 투자) = 연간 500배 수익
```

### 7. 보안 영향도 심층 분석

**예시: 리뷰 #5 (입력 검증 누락)**

```
문제: @Valid 어노테이션 없음

보안 영향도 분석:

OWASP Top 10 관점:
┌─────────────────────────────────────────────────┐
│ A03:2021 - Injection                            │
├─────────────────────────────────────────────────┤
│ 현재 위험:                                      │
│ - category, name에 길이 제한 없음              │
│ - 악의적 사용자가 10MB 문자열 전송 가능        │
│ - DB 컬럼 크기 초과 시 SQLException 발생       │
│ - 에러 메시지에서 DB 스키마 정보 유출 가능     │
│                                                 │
│ 공격 시나리오:                                  │
│ POST /create/product                            │
│ {                                               │
│   "category": "A".repeat(1000000),              │
│   "name": "'; DROP TABLE product; --"           │
│ }                                               │
│                                                 │
│ 결과:                                           │
│ - 메모리 부족 (OOM)                             │
│ - 서버 전체 다운                                │
│ - DDoS 효과                                     │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│ A04:2021 - Insecure Design                     │
├─────────────────────────────────────────────────┤
│ 비즈니스 로직 우회:                             │
│ - 상품명에 HTML/JS 삽입 시 XSS 가능            │
│ - 관리자 페이지에서 상품명 표시 시 스크립트 실행│
│                                                 │
│ 예시:                                           │
│ {                                               │
│   "name": "<script>document.cookie</script>"    │
│ }                                               │
│                                                 │
│ 영향:                                           │
│ - 관리자 세션 탈취                              │
│ - 내부 시스템 접근                              │
└─────────────────────────────────────────────────┘

실제 피해 추정:
1. 서비스 중단 시간: 2시간
2. 고객 이탈: 5%
3. 금전적 손실: 거래액의 0.1%
4. 신뢰도 하락: 측정 불가

예방 비용 vs 피해 비용:
- 예방 (검증 추가): 1시간 개발
- 피해 (공격 받을 시): 수천만원 + 평판 손실

심각도 등급: Critical
CVSS Score: 7.5 (High)
```

### 8. 성능 영향도 정량화

**예시: 리뷰 #19 (불필요한 조회)**

```
문제: 삭제 전 불필요한 조회

성능 영향 정량 분석:

현재 상황:
- 하루 상품 삭제: 1,000건
- 각 삭제마다 불필요한 SELECT 1회
- 하루 총 낭비 쿼리: 1,000회

쿼리 비용 측정:
┌────────────────────────┬──────────┬──────────┐
│ 작업                   │ 현재     │ 개선 후  │
├────────────────────────┼──────────┼──────────┤
│ SELECT * FROM product  │ 50ms     │ 0ms      │
│ DELETE FROM product    │ 30ms     │ 30ms     │
│ 총 시간                │ 80ms     │ 30ms     │
│ 개선율                 │ -        │ 62.5%    │
└────────────────────────┴──────────┴──────────┘

하루 기준 절감:
- 시간 절감: 1,000건 × 50ms = 50초
- 큰 문제 아닌 것처럼 보이지만...

확장성 분석:
서비스 성장 시나리오 (2년 후):
- 일일 삭제: 10,000건
- 낭비 시간: 500초 = 8.3분
- DB 커넥션 점유: 8.3분 동안 추가 커넥션 필요
- 커넥션 풀 크기: 20개
- 점유율: 8.3분 / 1440분 = 0.58%

동시성 영향:
- 피크 시간대 (PM 8-9시) 삭제 요청: 200 TPS
- 불필요한 SELECT로 인한 추가 부하: 200 QPS
- DB CPU 사용률: 10% 추가 증가
- 결과: 피크 타임 DB CPU 90% → 임계값 근접

비용 분석:
현재 환경 (RDS db.t3.medium):
- 추가 DB 부하로 인한 업그레이드 필요성: 1년 후
- db.t3.large로 업그레이드 비용: 월 $140 증가
- 연간 비용: $1,680

개선 비용:
- 코드 수정: 5분
- 테스트: 10분
- 총 투자: 15분

ROI: $1,680 / 15분 = 연간 투자 대비 6,720배 수익

왜 지금 고쳐야 하는가?
- 현재는 문제 없어 보임
- 하지만 서비스 성장 시 병목점
- 나중에 고치려면 프로파일링, 원인 분석 등 추가 비용
- "미리 아는 병목점"은 지금 고치는 게 100배 저렴
```

---

## 🔍 추가로 다뤄야 할 리뷰 포인트

### 1. 테스트 가능성 (현재 누락)

```
[신규 리뷰 - 테스트하기 어려운 구조]

문제: 현재 코드는 단위 테스트 작성이 매우 어려움

왜 테스트가 어려운가?

1. Service가 구체 클래스에 의존:
   - ProductService가 ProductRepository에 직접 의존
   - Mock 주입은 가능하지만 인터페이스 기반 설계가 더 명확

2. 트랜잭션 경계 불명확:
   - @Transactional 없어서 테스트 시 실제 DB 커밋 발생
   - 테스트 격리 어려움

3. 정적 의존성:
   - new RuntimeException() 직접 생성
   - 예외 발생 테스트 시 실제 예외 던져야 함

테스트 불가능으로 인한 실제 문제:

시나리오: "상품 수정 기능에 버그가 있다는 제보"
1. 현재 상황:
   - 단위 테스트 없음
   - 수정하려면 전체 앱 실행 필요
   - Postman으로 수동 테스트
   - 디버깅 시간: 30분

2. 테스트 가능한 구조:
   - 단위 테스트 실행
   - 5초 만에 버그 발견
   - 수정 후 즉시 검증
   - 디버깅 시간: 2분

버그 수정 사이클:
- 현재: 30분 (개발) + 10분 (QA 재검증) = 40분
- 개선 후: 2분 (개발) + 자동화된 테스트 = 2분
- 시간 절감: 95%

장기적 영향:
- 연간 버그 수정: 50건
- 절감 시간: 50건 × 38분 = 31시간
- 비용 절감: 개발자 시급 기준 약 200만원
```

### 2. API 진화 전략 (현재 누락)

```
[신규 리뷰 - API 버전 관리 전략 부재]

문제: /create/product 같은 URL은 버전 관리 불가

왜 이것이 중요한가?

1년 후 시나리오:
- Product에 stock(재고) 필드 추가 필요
- 기존 API: {category, name}만 받음
- 새 요구사항: {category, name, stock} 필요

현재 구조의 문제:
1. URL 변경 불가:
   - /create/product는 이미 클라이언트가 사용 중
   - 변경 시 모든 클라이언트 업데이트 필요

2. 하위 호환성 깨짐:
   - Product 엔티티에 stock 필드 추가
   - stock이 null인 상품 생성됨
   - 비즈니스 로직 깨짐

3. 해결책 없음:
   - 새 API 만들어야 함: /create/product/v2?
   - 일관성 없는 URL 구조
   - 기술 부채 누적

올바른 방법:
/api/v1/products → 현재 버전
/api/v2/products → 향후 버전

장점:
- 점진적 마이그레이션 가능
- 구버전 클라이언트 계속 동작
- 명확한 deprecation 정책 수립 가능

실제 비용:
- 버전 관리 없이 API 변경: 클라이언트 강제 업데이트
- 모바일 앱 사용자의 30%는 업데이트 안 함
- 결과: 30% 사용자 이탈 또는 서비스 불가

예방 비용:
- 지금 /api/v1/products 구조로 변경: 1시간
- 나중에 버전 관리 도입: 1주일 + 마이그레이션 리스크
```

### 3. 로깅 전략 (현재 부족)

```
[신규 리뷰 - 운영 환경 문제 추적 불가]

문제: 로깅이 거의 없어 장애 발생 시 원인 파악 불가

현재 로깅 상태:
- GlobalExceptionHandler에만 에러 로그
- 비즈니스 로직 실행 이력 없음
- 성공한 요청은 로그 없음

실제 장애 시나리오:

상황: "고객이 상품 수정했는데 반영 안 됐다고 클레임"
┌─────────────────────────────────────────┐
│ 현재 상황 (로그 없음)                   │
├─────────────────────────────────────────┤
│ 1. 에러 로그 확인 → 없음                │
│ 2. DB 확인 → 데이터 변경 안 됨          │
│ 3. 원인 추적 불가:                      │
│    - 요청이 들어왔나?                   │
│    - 어떤 값으로 수정 시도했나?         │
│    - 어느 단계에서 실패했나?            │
│ 4. 고객에게 "재현해주세요" 요청         │
│ 5. 고객 불만 증가                       │
│ 6. 원인 파악 실패                       │
│                                         │
│ 소요 시간: 2시간 (결론: 모름)           │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ 개선 후 (구조화된 로깅)                 │
├─────────────────────────────────────────┤
│ 로그:                                   │
│ [INFO] UpdateProduct - userId: 12345    │
│        productId: 999                   │
│        changes: {category: A→B}         │
│ [WARN] ProductNotFound - productId: 999│
│        userId: 12345                    │
│        timestamp: 2024-01-09 14:30:00   │
│                                         │
│ 1. 로그 검색: "productId: 999"          │
│ 2. 즉시 발견: 상품이 존재하지 않음      │
│ 3. 원인: 다른 사용자가 먼저 삭제함      │
│ 4. 고객에게 명확히 설명 가능            │
│                                         │
│ 소요 시간: 2분 (명확한 결론)            │
└─────────────────────────────────────────┘

필요한 로깅:
1. 요청 시작/종료 로그
2. 주요 비즈니스 이벤트
3. 데이터 변경 이력
4. 성능 메트릭 (응답 시간)
5. 사용자 행동 추적

로깅 부재로 인한 연간 비용:
- 장애 대응 시간 증가: 월 10건 × 2시간 = 연 240시간
- 비용: 시니어 개발자 투입 기준 1,200만원
- 고객 불만: 측정 불가

로깅 구축 비용:
- AOP로 자동 로깅 구현: 4시간
- Logback 설정: 2시간
- 총 투자: 6시간

ROI: 1,200만원 / 6시간 = 연간 2,000배 수익
```

---

## 💡 리뷰 작성 시 자가 점검 리스트

각 리뷰 작성 후 다음을 확인하세요:

### ✅ "왜" 체크리스트

- [ ] **비즈니스 영향도**: 이 문제가 매출/고객/평판에 미치는 영향을 설명했는가?
- [ ] **실제 시나리오**: 운영 환경에서 발생 가능한 구체적 상황을 제시했는가?
- [ ] **우선순위 근거**: 왜 Critical/High/Medium인지 정량적 기준을 제시했는가?
- [ ] **트레이드오프**: 각 대안의 장단점과 선택 기준을 명확히 했는가?
- [ ] **비용 분석**: 수정 비용 vs 미수정 시 손실을 비교했는가?
- [ ] **장기적 관점**: 6개월/1년 후를 고려했는가?
- [ ] **의사결정 근거**: "왜 이 방법을 선택했는가"가 명확한가?

### ✅ 심층 분석 체크리스트

- [ ] **운영 시나리오**: "만약 이 코드가 일 100만 요청을 처리한다면?" 분석
- [ ] **동시성 이슈**: 여러 요청이 동시에 들어올 때 문제 없는가?
- [ ] **확장성**: 서비스가 10배 성장하면 어떻게 되는가?
- [ ] **보안 영향도**: OWASP 기준으로 분석했는가?
- [ ] **테스트 가능성**: 이 코드를 어떻게 테스트할 것인가?
- [ ] **유지보수성**: 6개월 후 다른 개발자가 수정할 수 있는가?

### ✅ 정량화 체크리스트

- [ ] **성능 수치**: ms, QPS, 쿼리 수 등 구체적 숫자 제시
- [ ] **비용 산정**: 개발 시간, 금전적 손실 등을 계산
- [ ] **ROI 분석**: 투자 대비 효과를 명확히 제시
- [ ] **리스크 확률**: 문제 발생 가능성을 퍼센트로 표현

---

## 🎓 면접 대비 "왜" 질문들

리뷰한 내용에 대해 이런 질문을 받을 수 있습니다:

### Critical 이슈 관련
1. "왜 이것이 Critical인가요? High가 아니라?"
2. "이 문제를 안 고치면 어떤 장애가 발생하나요?"
3. "수정 비용과 미수정 시 리스크를 비교해주세요"

### 기술적 선택 관련
4. "왜 A가 아니라 B를 선택했나요?"
5. "B의 단점은 무엇이고, 어떻게 완화할 건가요?"
6. "실제 운영 환경에서 이 개선의 효과를 어떻게 측정하나요?"

### 트레이드오프 관련
7. "성능을 위해 복잡도가 증가하는데, 적절한 선택인가요?"
8. "단기적으로는 문제없는데 왜 지금 고쳐야 하나요?"
9. "이 개선이 정말 비용 대비 효과가 있나요?"

### 대안 분석 관련
10. "제안한 방법 말고 다른 방법은 없나요?"
11. "각 방법의 장단점을 비교해주세요"
12. "회사의 상황에 따라 선택이 달라질 수 있나요?"

---

## 🎯 결론

좋은 코드 리뷰는:

1. **"무엇"이 문제인지** 지적하는 것이 아니라
2. **"왜"** 문제인지 설명하고
3. **"왜"** 특정 해결책을 선택해야 하는지 근거를 제시하며
4. **"왜"** 지금 고쳐야 하는지 우선순위 판단 근거를 명확히 하는 것

현재 리뷰는 기술적으로 정확하지만, 위의 "왜" 관점들을 추가하면 훨씬 더 설득력 있고 실무적인 리뷰가 될 것입니다.
